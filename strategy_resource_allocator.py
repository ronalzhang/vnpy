#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Á≠ñÁï•ËµÑÊ∫êÂàÜÈÖçÂô®
Âü∫‰∫éKellyÂáÜÂàôÁöÑËµÑÈáëÂä®ÊÄÅÂàÜÈÖç‰∏éÁ≠ñÁï•ÁªÑÂêà‰ºòÂåñ

‰ΩúËÄÖ: Á≥ªÁªüÊû∂ÊûÑ‰ºòÂåñÂõ¢Èòü
Êó•Êúü: 2025Âπ¥6Êúà8Êó•
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Union, Optional
import logging
import json
import os
from datetime import datetime
from collections import defaultdict
import sqlite3
import math
from decimal import Decimal

# ÈÖçÁΩÆÊó•Âøó
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)s | %(message)s',
    handlers=[
        logging.FileHandler('logs/resource_allocator.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Â∞ùËØïÂØºÂÖ•Â∏ÇÂú∫ÁéØÂ¢ÉÂàÜÁ±ªÂô®
try:
    from market_environment_classifier import get_market_classifier
except ImportError:
    logger.warning("Â∏ÇÂú∫ÁéØÂ¢ÉÂàÜÁ±ªÂô®Êú™ÊâæÂà∞ÔºåÈÉ®ÂàÜÂäüËÉΩÂ∞ÜÂèóÈôê")
    get_market_classifier = None


class StrategyResourceAllocator:
    """Á≠ñÁï•ËµÑÊ∫êÂàÜÈÖçÂô® - Âü∫‰∫éKellyÂáÜÂàôÁöÑËµÑÈáëÂä®ÊÄÅÂàÜÈÖç‰∏éÁ≠ñÁï•ÁªÑÂêà‰ºòÂåñ"""
    
    def __init__(self, config_file="resource_allocator_config.json"):
        """ÂàùÂßãÂåñÁ≠ñÁï•ËµÑÊ∫êÂàÜÈÖçÂô®"""
        self.config = self._load_config(config_file)
        
        # ËµÑÈáëÂàÜÈÖçËÆ∞ÂΩï
        self.allocation_history = []
        
        # Á≠ñÁï•Ë°®Áé∞ËÆ∞ÂΩï
        self.strategy_performance = {}
        
        # Á≠ñÁï•Áõ∏ÂÖ≥ÊÄßÁü©Èòµ
        self.correlation_matrix = {}
        
        # ÊúÄËøë‰∏ÄÊ¨°ÂàÜÈÖçÁªìÊûúÁºìÂ≠ò
        self.last_allocation = {}
        
        # ËøûÊé•Êï∞ÊçÆÂ∫ì
        self.db_connection = self._connect_database()
        
        # Âä†ËΩΩÂ∏ÇÂú∫ÂàÜÁ±ªÂô®
        self.market_classifier = get_market_classifier() if get_market_classifier else None
        
        # ÂàùÂßãÂåñÂÆåÊàê
        logger.info("üöÄ Á≠ñÁï•ËµÑÊ∫êÂàÜÈÖçÂô®ÂàùÂßãÂåñÂÆåÊàê")
    
    def _load_config(self, config_file: str) -> Dict:
        """Âä†ËΩΩÈÖçÁΩÆÊñá‰ª∂"""
        default_config = {
            "min_allocation": 0.05,        # ÊúÄÂ∞èËµÑÈáëÂàÜÈÖçÊØî‰æã
            "max_allocation": 0.7,         # ÊúÄÂ§ßËµÑÈáëÂàÜÈÖçÊØî‰æã
            "reserve_ratio": 0.1,          # ‰øùÁïôËµÑÈáëÊØî‰æã
            "performance_window": 30,      # ÊÄßËÉΩËØÑ‰º∞Á™óÂè£(Â§©)
            "kelly_fraction": 0.5,         # KellyÁ≥ªÊï∞ (ÂçäKellyÊõ¥‰øùÂÆà)
            "correlation_threshold": 0.7,  # Áõ∏ÂÖ≥ÊÄßÈòàÂÄº
            "diversity_weight": 0.3,       # Â§öÊ†∑ÊÄßÊùÉÈáç
            "min_trades": 10,              # ÊúÄÂ∞ë‰∫§ÊòìÊ¨°Êï∞Ë¶ÅÊ±Ç
            "high_score_threshold": 70,    # È´òÂàÜÁ≠ñÁï•ÈòàÂÄº
            "low_score_threshold": 50,     # ‰ΩéÂàÜÁ≠ñÁï•ÈòàÂÄº
            "max_strategies": 5,           # ÊúÄÂ§ßÂêåÊó∂ËøêË°åÁ≠ñÁï•Êï∞
            "database_path": "quantitative.db",  # Êï∞ÊçÆÂ∫ìË∑ØÂæÑ
            "dynamic_adjustment": True,    # ÊòØÂê¶Ê†πÊçÆÂ∏ÇÂú∫Áä∂ÊÄÅÂä®ÊÄÅË∞ÉÊï¥
            "adjustment_frequency": "daily" # Ë∞ÉÊï¥È¢ëÁéá: daily, weekly, monthly
        }
        
        try:
            if os.path.exists(config_file):
                with open(config_file, 'r') as f:
                    config = json.load(f)
                # ÂêàÂπ∂ÈÖçÁΩÆ‰∏éÈªòËÆ§ÂÄº
                for key, value in default_config.items():
                    if key not in config:
                        config[key] = value
                return config
            else:
                logger.warning(f"ÈÖçÁΩÆÊñá‰ª∂ {config_file} ‰∏çÂ≠òÂú®Ôºå‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆ")
                return default_config
        except Exception as e:
            logger.error(f"Âä†ËΩΩÈÖçÁΩÆÊñá‰ª∂Â§±Ë¥•: {e}")
            return default_config
    
    def _connect_database(self):
        """ËøûÊé•Âà∞Êï∞ÊçÆÂ∫ì"""
        try:
            db_path = self.config["database_path"]
            conn = sqlite3.connect(db_path)
            conn.row_factory = sqlite3.Row
            return conn
        except Exception as e:
            logger.error(f"Êï∞ÊçÆÂ∫ìËøûÊé•Â§±Ë¥•: {e}")
            return None
    
    def save_state(self, filepath="data/resource_allocator_state.json"):
        """‰øùÂ≠òÂàÜÈÖçÂô®Áä∂ÊÄÅ"""
        try:
            state = {
                "allocation_history": self.allocation_history[-50:],  # Âè™‰øùÁïôÊúÄËøë50Êù°ËÆ∞ÂΩï
                "strategy_performance": self.strategy_performance,
                "correlation_matrix": self.correlation_matrix,
                "last_allocation": self.last_allocation,
                "timestamp": datetime.now().isoformat()
            }
            
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            with open(filepath, 'w') as f:
                json.dump(state, f, indent=2, default=str)
            logger.info(f"ËµÑÊ∫êÂàÜÈÖçÂô®Áä∂ÊÄÅÂ∑≤‰øùÂ≠òÂà∞ {filepath}")
            return True
        except Exception as e:
            logger.error(f"‰øùÂ≠òÁä∂ÊÄÅÂ§±Ë¥•: {e}")
            return False
    
    def load_state(self, filepath="data/resource_allocator_state.json"):
        """Âä†ËΩΩÂàÜÈÖçÂô®Áä∂ÊÄÅ"""
        try:
            if os.path.exists(filepath):
                with open(filepath, 'r') as f:
                    state = json.load(f)
                
                self.allocation_history = state.get("allocation_history", [])
                self.strategy_performance = state.get("strategy_performance", {})
                self.correlation_matrix = state.get("correlation_matrix", {})
                self.last_allocation = state.get("last_allocation", {})
                
                logger.info(f"ËµÑÊ∫êÂàÜÈÖçÂô®Áä∂ÊÄÅÂ∑≤‰ªé {filepath} Âä†ËΩΩ")
                return True
            else:
                logger.warning(f"Áä∂ÊÄÅÊñá‰ª∂ {filepath} ‰∏çÂ≠òÂú®")
                return False
        except Exception as e:
            logger.error(f"Âä†ËΩΩÁä∂ÊÄÅÂ§±Ë¥•: {e}")
            return False
    
    def update_strategy_performance(self, strategy_id: str, metrics: Dict) -> None:
        """Êõ¥Êñ∞Á≠ñÁï•ÊÄßËÉΩÊåáÊ†á"""
        if strategy_id not in self.strategy_performance:
            self.strategy_performance[strategy_id] = []
        
        # Ê∑ªÂä†Êó∂Èó¥Êà≥
        metrics["timestamp"] = datetime.now().isoformat()
        
        # Á°Æ‰øùÂ≠óÊÆµÂ≠òÂú®
        required_fields = ["win_rate", "profit_factor", "sharpe_ratio", "max_drawdown", "total_pnl"]
        for field in required_fields:
            if field not in metrics:
                metrics[field] = 0.0
        
        # Ê∑ªÂä†ËÆ∞ÂΩï
        self.strategy_performance[strategy_id].append(metrics)
        
        # ‰øùÊåÅËÆ∞ÂΩïÂú®ÂêàÁêÜËåÉÂõ¥ÂÜÖ
        max_records = 100
        if len(self.strategy_performance[strategy_id]) > max_records:
            self.strategy_performance[strategy_id] = self.strategy_performance[strategy_id][-max_records:]
            
        logger.info(f"Á≠ñÁï• {strategy_id} ÊÄßËÉΩÊåáÊ†áÂ∑≤Êõ¥Êñ∞")
    
    def update_strategy_performances_from_db(self) -> None:
        """‰ªéÊï∞ÊçÆÂ∫ìÊõ¥Êñ∞ÂÖ®ÈÉ®Á≠ñÁï•ÊÄßËÉΩÊåáÊ†á"""
        if not self.db_connection:
            logger.error("Êï∞ÊçÆÂ∫ìÊú™ËøûÊé•ÔºåÊó†Ê≥ïÊõ¥Êñ∞Á≠ñÁï•ÊÄßËÉΩ")
            return
        
        try:
            cursor = self.db_connection.cursor()
            
            # Ëé∑ÂèñÊ¥ªË∑ÉÁ≠ñÁï•
            cursor.execute("""
                SELECT id, name, final_score, created_at 
                FROM strategies 
                WHERE enabled = 1
            """)
            
            strategies = cursor.fetchall()
            logger.info(f"‰ªéÊï∞ÊçÆÂ∫ìËé∑ÂèñÂà∞ {len(strategies)} ‰∏™Ê¥ªË∑ÉÁ≠ñÁï•")
            
            for strategy in strategies:
                strategy_id = strategy["id"]
                
                # Ëé∑ÂèñÁ≠ñÁï•‰∫§ÊòìËÆ∞ÂΩï
                cursor.execute("""
                    SELECT 
                        COUNT(*) as total_trades,
                        SUM(CASE WHEN pnl > 0 THEN 1 ELSE 0 END) as winning_trades,
                        SUM(pnl) as total_pnl,
                        AVG(pnl) as avg_pnl,
                        MAX(pnl) as max_pnl,
                        MIN(pnl) as min_pnl
                    FROM strategy_trade_logs 
                    WHERE strategy_id = ? AND timestamp > datetime('now', '-30 days')
                """, (strategy_id,))
                
                trade_stats = cursor.fetchone()
                
                if not trade_stats or trade_stats["total_trades"] == 0:
                    logger.warning(f"Á≠ñÁï• {strategy_id} Ê≤°ÊúâËøëÊúü‰∫§ÊòìËÆ∞ÂΩï")
                    continue
                
                # ËÆ°ÁÆóÂêÑÈ°πÊåáÊ†á
                total_trades = trade_stats["total_trades"]
                winning_trades = trade_stats["winning_trades"] or 0
                win_rate = winning_trades / total_trades if total_trades > 0 else 0
                
                # ËÆ°ÁÆóÁõà‰∫èÊØî
                profit_factor = 1.0
                cursor.execute("""
                    SELECT 
                        SUM(CASE WHEN pnl > 0 THEN pnl ELSE 0 END) as gross_profit,
                        ABS(SUM(CASE WHEN pnl < 0 THEN pnl ELSE 0 END)) as gross_loss
                    FROM strategy_trade_logs 
                    WHERE strategy_id = ? AND timestamp > datetime('now', '-30 days')
                """, (strategy_id,))
                
                pnl_stats = cursor.fetchone()
                if pnl_stats and pnl_stats["gross_loss"] > 0:
                    profit_factor = (pnl_stats["gross_profit"] or 0) / pnl_stats["gross_loss"]
                
                # Ëé∑ÂèñÂõûÊí§Êï∞ÊçÆ
                cursor.execute("""
                    SELECT MAX(drawdown) as max_drawdown
                    FROM strategy_statistics
                    WHERE strategy_id = ? AND timestamp > datetime('now', '-30 days')
                """, (strategy_id,))
                
                drawdown_stats = cursor.fetchone()
                max_drawdown = drawdown_stats["max_drawdown"] if drawdown_stats else 0.05
                
                # ËÆ°ÁÆóÂ§èÊôÆÊØîÁéá (ÁÆÄÂåñÁâà)
                cursor.execute("""
                    SELECT pnl FROM strategy_trade_logs 
                    WHERE strategy_id = ? AND timestamp > datetime('now', '-30 days')
                    ORDER BY timestamp
                """, (strategy_id,))
                
                pnl_values = [row["pnl"] for row in cursor.fetchall()]
                sharpe_ratio = 0.0
                if pnl_values:
                    returns = np.array(pnl_values)
                    if len(returns) > 1 and np.std(returns) > 0:
                        sharpe_ratio = np.mean(returns) / np.std(returns) * np.sqrt(252)  # Âπ¥Âåñ
                
                # ÁªÑÂêàÊåáÊ†á
                metrics = {
                    "win_rate": win_rate,
                    "profit_factor": profit_factor,
                    "sharpe_ratio": sharpe_ratio,
                    "max_drawdown": max_drawdown,
                    "total_pnl": trade_stats["total_pnl"] or 0,
                    "total_trades": total_trades,
                    "score": strategy["final_score"] or 50
                }
                
                # Êõ¥Êñ∞Á≠ñÁï•ÊÄßËÉΩËÆ∞ÂΩï
                self.update_strategy_performance(strategy_id, metrics)
                
            # ËÆ°ÁÆóÁ≠ñÁï•Áõ∏ÂÖ≥ÊÄß
            self._calculate_strategy_correlations()
                
            logger.info("Á≠ñÁï•ÊÄßËÉΩÊåáÊ†áÂ∑≤‰ªéÊï∞ÊçÆÂ∫ìÊõ¥Êñ∞")
            
        except Exception as e:
            logger.error(f"‰ªéÊï∞ÊçÆÂ∫ìÊõ¥Êñ∞Á≠ñÁï•ÊÄßËÉΩÂ§±Ë¥•: {e}")
    
    def _calculate_strategy_correlations(self) -> None:
        """ËÆ°ÁÆóÁ≠ñÁï•Êî∂ÁõäÁõ∏ÂÖ≥ÊÄßÁü©Èòµ"""
        if not self.db_connection:
            logger.error("Êï∞ÊçÆÂ∫ìÊú™ËøûÊé•ÔºåÊó†Ê≥ïËÆ°ÁÆóÁõ∏ÂÖ≥ÊÄß")
            return
        
        try:
            cursor = self.db_connection.cursor()
            
            # Ëé∑ÂèñÊ¥ªË∑ÉÁ≠ñÁï•ÂàóË°®
            cursor.execute("SELECT id FROM strategies WHERE enabled = 1")
            strategies = [row["id"] for row in cursor.fetchall()]
            
            if len(strategies) <= 1:
                logger.warning("Ê¥ªË∑ÉÁ≠ñÁï•‰∏çË∂≥ÔºåÊó†Ê≥ïËÆ°ÁÆóÁõ∏ÂÖ≥ÊÄß")
                return
            
            # ÂàùÂßãÂåñÁªìÊûúÁü©Èòµ
            self.correlation_matrix = {}
            
            # Ëé∑ÂèñÊØè‰∏™Á≠ñÁï•ÁöÑÊØèÊó•Êî∂Áõä
            strategy_returns = {}
            for strategy_id in strategies:
                cursor.execute("""
                    SELECT DATE(timestamp) as date, SUM(pnl) as daily_pnl
                    FROM strategy_trade_logs
                    WHERE strategy_id = ? AND timestamp > datetime('now', '-60 days')
                    GROUP BY DATE(timestamp)
                    ORDER BY date
                """, (strategy_id,))
                
                daily_returns = {}
                for row in cursor.fetchall():
                    daily_returns[row["date"]] = row["daily_pnl"] or 0
                
                strategy_returns[strategy_id] = daily_returns
            
            # Â∞ÜÊØèÊó•Êî∂ÁõäËΩ¨Êç¢‰∏∫DataFrameËøõË°åÁõ∏ÂÖ≥ÊÄßËÆ°ÁÆó
            dates = set()
            for returns in strategy_returns.values():
                dates.update(returns.keys())
            
            dates = sorted(list(dates))
            if not dates:
                logger.warning("Ê≤°ÊúâË∂≥Â§üÁöÑÂéÜÂè≤Êï∞ÊçÆËÆ°ÁÆóÁõ∏ÂÖ≥ÊÄß")
                return
                
            # ÊûÑÂª∫DataFrame
            data = {}
            for strategy_id, returns in strategy_returns.items():
                data[strategy_id] = [returns.get(date, 0) for date in dates]
            
            df = pd.DataFrame(data, index=dates)
            
            # ËÆ°ÁÆóÁõ∏ÂÖ≥ÊÄßÁü©Èòµ
            if df.shape[1] > 1:  # Ëá≥Â∞ëÈúÄË¶Å‰∏§‰∏™Á≠ñÁï•ÊâçËÉΩËÆ°ÁÆóÁõ∏ÂÖ≥ÊÄß
                correlation = df.corr()
                
                # ËΩ¨Êç¢‰∏∫Â≠óÂÖ∏Ê†ºÂºè
                for i in range(len(strategies)):
                    for j in range(i+1, len(strategies)):
                        id1 = strategies[i]
                        id2 = strategies[j]
                        if id1 in correlation.index and id2 in correlation.columns:
                            corr_value = correlation.loc[id1, id2]
                            if not pd.isna(corr_value):
                                key = f"{id1}:{id2}"
                                self.correlation_matrix[key] = float(corr_value)
            
            logger.info(f"Â∑≤ËÆ°ÁÆó {len(self.correlation_matrix)} ÂØπÁ≠ñÁï•ÁöÑÁõ∏ÂÖ≥ÊÄß")
            
        except Exception as e:
            logger.error(f"ËÆ°ÁÆóÁ≠ñÁï•Áõ∏ÂÖ≥ÊÄßÂ§±Ë¥•: {e}")
    
    def get_correlation(self, strategy1: str, strategy2: str) -> float:
        """Ëé∑Âèñ‰∏§‰∏™Á≠ñÁï•ÁöÑÁõ∏ÂÖ≥ÊÄß"""
        key1 = f"{strategy1}:{strategy2}"
        key2 = f"{strategy2}:{strategy1}"
        
        if key1 in self.correlation_matrix:
            return self.correlation_matrix[key1]
        elif key2 in self.correlation_matrix:
            return self.correlation_matrix[key2]
        else:
            # ÈªòËÆ§Áõ∏ÂÖ≥ÊÄß‰∏∫0.5
            return 0.5
    
    def get_strategy_metrics(self, strategy_id: str) -> Dict:
        """Ëé∑ÂèñÁ≠ñÁï•ÁöÑÊúÄÊñ∞ÊÄßËÉΩÊåáÊ†á"""
        if strategy_id in self.strategy_performance and self.strategy_performance[strategy_id]:
            return self.strategy_performance[strategy_id][-1]
        else:
            # Ê≤°ÊúâÊÄßËÉΩËÆ∞ÂΩïÊó∂ÁöÑÈªòËÆ§ÂÄº
            return {
                "win_rate": 0.5,
                "profit_factor": 1.0,
                "sharpe_ratio": 0.0,
                "max_drawdown": 0.05,
                "total_pnl": 0.0,
                "total_trades": 0,
                "score": 50.0
            }
    
    def calculate_kelly_position(self, strategy_id: str) -> float:
        """‰ΩøÁî®KellyÂáÜÂàôËÆ°ÁÆóÁ≠ñÁï•ÊúÄ‰ºò‰ªì‰Ωç"""
        metrics = self.get_strategy_metrics(strategy_id)
        
        win_rate = metrics["win_rate"]
        profit_factor = metrics["profit_factor"]
        
        # Â¶ÇÊûúÊ≤°Êúâ‰∫§ÊòìËÆ∞ÂΩïÊàñÂà©Ê∂¶Âõ†Â≠ê‰∏∫0ÔºåËøîÂõûÊúÄÂ∞èÂàÜÈÖç
        if metrics["total_trades"] < self.config["min_trades"] or profit_factor <= 0:
            return self.config["min_allocation"]
        
        # ËÆ°ÁÆóËµîÁéá
        if profit_factor > 1:
            odds = profit_factor
        else:
            odds = 1.0
        
        # KellyÂÖ¨Âºè: K = (p*(b+1)-1)/bÔºåÂÖ∂‰∏≠p‰∏∫ËÉúÁéáÔºåb‰∏∫ËµîÁéá
        kelly = (win_rate * (odds + 1) - 1) / odds
        
        # Â∫îÁî®KellyÂàÜÊï∞Âπ∂ÈôêÂà∂ËåÉÂõ¥
        kelly_fraction = self.config["kelly_fraction"]
        position = kelly * kelly_fraction
        
        # ÈôêÂà∂ÊúÄÂ§ßÊúÄÂ∞èÂÄº
        position = max(self.config["min_allocation"], 
                     min(self.config["max_allocation"], position))
        
        logger.info(f"Á≠ñÁï• {strategy_id} Kelly‰ªì‰Ωç: {position:.4f} (ËÉúÁéá: {win_rate:.2f}, ËµîÁéá: {odds:.2f})")
        return position
    
    def _apply_market_adjustment(self, allocations: Dict[str, float], 
                               market_state: str = None) -> Dict[str, float]:
        """Ê†πÊçÆÂ∏ÇÂú∫Áä∂ÊÄÅË∞ÉÊï¥ÂàÜÈÖç"""
        if not market_state or not self.market_classifier:
            return allocations
        
        # Ëé∑ÂèñÂΩìÂâçÂ∏ÇÂú∫Áä∂ÊÄÅ
        if market_state == "auto" and self.market_classifier:
            market_info = self.market_classifier.get_current_market_state()
            market_state = market_info["state"]
        
        # Ëé∑ÂèñËØ•Â∏ÇÂú∫Áä∂ÊÄÅ‰∏ãÁöÑÊé®ËçêÁ≠ñÁï•
        recommended = []
        if self.market_classifier:
            recommended = self.market_classifier.get_best_strategies_for_state(market_state, 3)
        
        # Â¶ÇÊûúÊ≤°ÊúâÊé®ËçêÔºå‰∏ç‰ΩúË∞ÉÊï¥
        if not recommended:
            return allocations
        
        # Âü∫‰∫éÊé®ËçêË∞ÉÊï¥ÂàÜÈÖç
        adjusted = allocations.copy()
        
        for strategy_id in allocations:
            # Ê£ÄÊü•Á≠ñÁï•Á±ªÂûãÊòØÂê¶Âú®Êé®ËçêÂàóË°®‰∏≠
            strategy_type = strategy_id.split('_')[0] if '_' in strategy_id else strategy_id
            
            if strategy_type in recommended:
                # Â¢ûÂä†Êé®ËçêÁ≠ñÁï•ÁöÑÂàÜÈÖç
                boost_factor = 1.5 if strategy_type == recommended[0] else 1.3
                adjusted[strategy_id] = adjusted[strategy_id] * boost_factor
            else:
                # ÂáèÂ∞ëÈùûÊé®ËçêÁ≠ñÁï•ÁöÑÂàÜÈÖç
                adjusted[strategy_id] = adjusted[strategy_id] * 0.7
        
        # ÈáçÊñ∞ÂΩí‰∏ÄÂåñ
        total = sum(adjusted.values())
        if total > 0:
            for strategy_id in adjusted:
                adjusted[strategy_id] = adjusted[strategy_id] / total
        
        return adjusted
    
    def optimize_allocations(self, eligible_strategies: List[str],
                           total_capital: float,
                           market_state: str = "auto") -> Dict:
        """
        ‰ºòÂåñÁ≠ñÁï•ËµÑÈáëÂàÜÈÖç
        :param eligible_strategies: ÂèØÈÄâÁ≠ñÁï•ÂàóË°®
        :param total_capital: ÊÄªËµÑÈáëÈáè
        :param market_state: Â∏ÇÂú∫Áä∂ÊÄÅÔºå"auto"Ë°®Á§∫Ëá™Âä®Ê£ÄÊµã
        :return: ÂàÜÈÖçÁªìÊûú
        """
        # Â¶ÇÊûúÊ≤°ÊúâÂèØÁî®Á≠ñÁï•ÔºåËøîÂõûÁ©∫ÂàÜÈÖç
        if not eligible_strategies:
            logger.warning("Ê≤°ÊúâÂèØÁî®Á≠ñÁï•ÔºåÊó†Ê≥ïËøõË°åÂàÜÈÖç‰ºòÂåñ")
            return {"allocations": {}, "total": 0, "reserve": total_capital}
        
        # Êõ¥Êñ∞Á≠ñÁï•ÊÄßËÉΩÊï∞ÊçÆ
        self.update_strategy_performances_from_db()
        
        # ËÆ°ÁÆóÊØè‰∏™Á≠ñÁï•ÁöÑÂàùÂßãKelly‰ªì‰Ωç
        initial_allocations = {}
        scores = {}
        
        for strategy_id in eligible_strategies:
            metrics = self.get_strategy_metrics(strategy_id)
            
            # Ê£ÄÊü•‰∫§ÊòìÈáèÊòØÂê¶Êª°Ë∂≥Ë¶ÅÊ±Ç
            if metrics["total_trades"] < self.config["min_trades"]:
                logger.info(f"Á≠ñÁï• {strategy_id} ‰∫§ÊòìÈáè‰∏çË∂≥ ({metrics['total_trades']}), ÂàÜÈÖçÊúÄ‰ΩéËµÑÈáë")
                initial_allocations[strategy_id] = self.config["min_allocation"]
            else:
                # ‰ΩøÁî®KellyËÆ°ÁÆó
                kelly_position = self.calculate_kelly_position(strategy_id)
                initial_allocations[strategy_id] = kelly_position
            
            # ËÆ∞ÂΩïÁ≠ñÁï•ÂàÜÊï∞
            scores[strategy_id] = metrics["score"]
        
        # Â∫îÁî®Á≠ñÁï•ÂàÜÊï∞Ë∞ÉÊï¥
        score_adjusted = {}
        for strategy_id, allocation in initial_allocations.items():
            score = scores[strategy_id]
            
            # ÂàÜÊï∞Ë∞ÉÊï¥Âõ†Â≠ê
            if score >= self.config["high_score_threshold"]:
                # È´òÂàÜÁ≠ñÁï•Â¢ûÂä†ÂàÜÈÖç
                factor = 1.0 + (score - self.config["high_score_threshold"]) / 100
            elif score <= self.config["low_score_threshold"]:
                # ‰ΩéÂàÜÁ≠ñÁï•ÂáèÂ∞ëÂàÜÈÖç
                factor = 0.5 + (score / self.config["low_score_threshold"]) * 0.5
            else:
                factor = 1.0
                
            score_adjusted[strategy_id] = allocation * factor
        
        # Â∫îÁî®Áõ∏ÂÖ≥ÊÄßË∞ÉÊï¥ÔºåÈôç‰ΩéÈ´òÁõ∏ÂÖ≥Á≠ñÁï•ÁöÑÊùÉÈáç
        correlation_adjusted = score_adjusted.copy()
        
        # Âè™ÊúâÂΩìÊúâÂ§ö‰∏™Á≠ñÁï•Êó∂ÊâçËøõË°åÁõ∏ÂÖ≥ÊÄßË∞ÉÊï¥
        if len(eligible_strategies) > 1:
            for i, strategy1 in enumerate(eligible_strategies):
                correlation_penalty = 0.0
                
                # ËÆ°ÁÆó‰∏éÂÖ∂‰ªñÁ≠ñÁï•ÁöÑÂπ≥ÂùáÁõ∏ÂÖ≥ÊÄß
                for j, strategy2 in enumerate(eligible_strategies):
                    if i != j:
                        correlation = abs(self.get_correlation(strategy1, strategy2))
                        # È´òÁõ∏ÂÖ≥ÊÄßÊñΩÂä†ÊÉ©ÁΩö
                        if correlation > self.config["correlation_threshold"]:
                            correlation_penalty += (correlation - self.config["correlation_threshold"]) * 0.5
                
                # Áõ∏ÂÖ≥ÊÄßÊùÉÈáçÊÉ©ÁΩöÔºåÊúÄÂ§öÈôç‰Ωé30%
                correlation_penalty = min(correlation_penalty, 0.3)
                correlation_adjusted[strategy1] *= (1 - correlation_penalty)
        
        # Â∫îÁî®Â∏ÇÂú∫Áä∂ÊÄÅË∞ÉÊï¥
        if market_state and self.config["dynamic_adjustment"]:
            correlation_adjusted = self._apply_market_adjustment(correlation_adjusted, market_state)
        
        # ÂΩí‰∏ÄÂåñÂπ∂Â∫îÁî®ÊúÄÂ§ßÁ≠ñÁï•Êï∞ÈôêÂà∂
        sorted_strategies = sorted(correlation_adjusted.items(), 
                                 key=lambda x: x[1], reverse=True)
        
        max_strategies = min(self.config["max_strategies"], len(eligible_strategies))
        selected_strategies = sorted_strategies[:max_strategies]
        
        # ËÆ°ÁÆóÊúÄÁªàÂàÜÈÖç
        final_allocations = {s[0]: s[1] for s in selected_strategies}
        total_weight = sum(final_allocations.values())
        
        normalized_allocations = {}
        for strategy_id, weight in final_allocations.items():
            normalized_allocations[strategy_id] = weight / total_weight if total_weight > 0 else 0
        
        # ËÆ°ÁÆóËµÑÈáëÂàÜÈÖç
        capital_allocations = {}
        available_capital = total_capital * (1 - self.config["reserve_ratio"])
        reserve = total_capital * self.config["reserve_ratio"]
        
        for strategy_id, ratio in normalized_allocations.items():
            capital_allocations[strategy_id] = available_capital * ratio
        
        # ËÆ∞ÂΩïÂàÜÈÖçÂéÜÂè≤
        allocation_record = {
            "timestamp": datetime.now().isoformat(),
            "market_state": market_state if market_state != "auto" else None,
            "total_capital": total_capital,
            "reserve": reserve,
            "allocations": capital_allocations
        }
        self.allocation_history.append(allocation_record)
        
        # Êõ¥Êñ∞ÊúÄËøëÂàÜÈÖçËÆ∞ÂΩï
        self.last_allocation = {
            "normalized": normalized_allocations,
            "capital": capital_allocations,
            "timestamp": datetime.now().isoformat(),
            "reserve": reserve,
            "total": total_capital
        }
        
        # ‰øùÂ≠òÁä∂ÊÄÅ
        self.save_state()
        
        result = {
            "allocations": capital_allocations,
            "normalized": normalized_allocations,
            "total": available_capital,
            "reserve": reserve,
            "market_state": market_state if market_state != "auto" else None,
            "timestamp": datetime.now().isoformat()
        }
        
        logger.info(f"Á≠ñÁï•ËµÑÈáëÂàÜÈÖç‰ºòÂåñÂÆåÊàêÔºåÂÖ±ÂàÜÈÖç {len(capital_allocations)} ‰∏™Á≠ñÁï•Ôºå‰øùÁïôËµÑÈáë {reserve:.2f}")
        return result
    
    def get_optimal_strategy_mix(self, available_strategies: List[Dict], 
                               max_strategies: int = None) -> List[str]:
        """
        Ëé∑ÂèñÊúÄ‰ºòÁ≠ñÁï•ÁªÑÂêà
        :param available_strategies: ÂèØÁî®Á≠ñÁï•ÂàóË°®ÔºåÂåÖÂê´Á≠ñÁï•IDÂíåÊÄßËÉΩÊåáÊ†á
        :param max_strategies: ÊúÄÂ§ßÁ≠ñÁï•Êï∞ÈáèÔºåÈªòËÆ§‰ΩøÁî®ÈÖçÁΩÆÂÄº
        :return: ÊúÄ‰ºòÁ≠ñÁï•IDÂàóË°®
        """
        if not available_strategies:
            return []
        
        # ‰ΩøÁî®ÈÖçÁΩÆ‰∏≠ÁöÑÊúÄÂ§ßÁ≠ñÁï•Êï∞
        if max_strategies is None:
            max_strategies = self.config["max_strategies"]
        
        # Â¶ÇÊûúÂèØÁî®Á≠ñÁï•Â∞ë‰∫éÁ≠â‰∫éÊúÄÂ§ßÊï∞ÈáèÔºåÁõ¥Êé•ËøîÂõûÂÖ®ÈÉ®
        if len(available_strategies) <= max_strategies:
            return [s["id"] for s in available_strategies]
        
        # ÊåâÂàÜÊï∞ÊéíÂ∫è
        strategies_by_score = sorted(available_strategies, 
                                  key=lambda x: x.get("score", 0), 
                                  reverse=True)
        
        # Ëé∑ÂèñÂ∏ÇÂú∫Áä∂ÊÄÅ
        market_state = None
        if self.market_classifier:
            market_info = self.market_classifier.get_current_market_state()
            market_state = market_info["state"]
            
            # Ëé∑ÂèñËØ•Â∏ÇÂú∫Áä∂ÊÄÅ‰∏ãÁöÑÊé®ËçêÁ≠ñÁï•Á±ªÂûã
            recommended_types = self.market_classifier.get_best_strategies_for_state(market_state)
            
            # ‰ºòÂÖàÈÄâÊã©Êé®ËçêÁöÑÁ≠ñÁï•Á±ªÂûã
            prioritized = []
            for s in strategies_by_score:
                strategy_type = s["id"].split('_')[0] if '_' in s["id"] else s["id"]
                if strategy_type in recommended_types:
                    s["priority_boost"] = True
                    prioritized.append(s)
            
            # Â¶ÇÊûúÊúâÊé®ËçêÁ≠ñÁï•ÔºåÁ°Æ‰øùËá≥Â∞ëÈÄâÊã©‰∏Ä‰∏™
            if prioritized and max_strategies > 1:
                selected = [prioritized[0]["id"]]
                # Ââ©‰ΩôÁöÑÁ≠ñÁï•ÊåâÁÖßÂÖ∂‰ªñÊ†áÂáÜÈÄâÊã©
                remaining = [s for s in strategies_by_score if s["id"] != prioritized[0]["id"]]
                max_strategies -= 1
            else:
                selected = []
                remaining = strategies_by_score
        else:
            selected = []
            remaining = strategies_by_score
        
        # ËÆ°ÁÆóÁ≠ñÁï•Èó¥Áõ∏ÂÖ≥ÊÄßÁü©Èòµ
        correlations = {}
        for i, s1 in enumerate(remaining):
            for j, s2 in enumerate(remaining):
                if i < j:
                    correlations[(s1["id"], s2["id"])] = self.get_correlation(s1["id"], s2["id"])
        
        # Ë¥™Â©™ÈÄâÊã©Á≠ñÁï•ÁªÑÂêà
        while len(selected) < max_strategies and remaining:
            best_addition = None
            best_score = -float('inf')
            
            for candidate in remaining:
                # ËÆ°ÁÆóÂÄôÈÄâÁ≠ñÁï•ÁöÑÂæóÂàÜ
                base_score = candidate.get("score", 50)
                
                # ‰∏éÂ∑≤ÈÄâÁ≠ñÁï•ÁöÑÂπ≥ÂùáÁõ∏ÂÖ≥ÊÄß
                avg_correlation = 0
                if selected:
                    corrs = []
                    for selected_id in selected:
                        key = (candidate["id"], selected_id) if candidate["id"] < selected_id else (selected_id, candidate["id"])
                        corrs.append(abs(correlations.get(key, 0.5)))
                    avg_correlation = sum(corrs) / len(corrs) if corrs else 0
                
                # Â§öÊ†∑ÊÄßÂ•ñÂä±
                diversity_score = (1 - avg_correlation) * 100 * self.config["diversity_weight"]
                
                # Â∏ÇÂú∫ÈÄÇÂ∫îÊÄßÂ•ñÂä±
                market_bonus = 10 if candidate.get("priority_boost", False) else 0
                
                # ÊÄªÂàÜ
                total_score = base_score + diversity_score + market_bonus
                
                if total_score > best_score:
                    best_score = total_score
                    best_addition = candidate
            
            if best_addition:
                selected.append(best_addition["id"])
                remaining.remove(best_addition)
            else:
                break
        
        logger.info(f"ÊúÄ‰ºòÁ≠ñÁï•ÁªÑÂêàÈÄâÊã©ÂÆåÊàê: {selected}")
        return selected
    
    def get_allocation_history(self, days: int = 7) -> List[Dict]:
        """Ëé∑ÂèñÂéÜÂè≤ÂàÜÈÖçËÆ∞ÂΩï"""
        if not self.allocation_history:
            return []
        
        # ËÆ°ÁÆóÊà™Ê≠¢Êó•Êúü
        cutoff = datetime.now() - timedelta(days=days)
        cutoff_str = cutoff.isoformat()
        
        # ËøáÊª§ËÆ∞ÂΩï
        recent_history = [
            record for record in self.allocation_history
            if record["timestamp"] > cutoff_str
        ]
        
        return recent_history
    
    def get_portfolio_metrics(self, allocations: Dict[str, float] = None) -> Dict:
        """ËÆ°ÁÆóÁªÑÂêàÁ≠ñÁï•ÁöÑÊÄßËÉΩÊåáÊ†á"""
        # Â¶ÇÊûúÊ≤°ÊúâÊèê‰æõÂàÜÈÖçÔºå‰ΩøÁî®ÊúÄËøëÁöÑÂàÜÈÖç
        if allocations is None:
            if not self.last_allocation:
                return {
                    "expected_return": 0.0,
                    "expected_risk": 0.05,
                    "sharpe_ratio": 0.0,
                    "win_rate": 0.5,
                    "correlation": 0.5,
                    "diversification": 0.5
                }
            allocations = self.last_allocation.get("normalized", {})
        
        # Â¶ÇÊûúÊ≤°ÊúâÂàÜÈÖçÔºåËøîÂõûÈªòËÆ§ÊåáÊ†á
        if not allocations:
            return {
                "expected_return": 0.0,
                "expected_risk": 0.05,
                "sharpe_ratio": 0.0,
                "win_rate": 0.5,
                "correlation": 0.5,
                "diversification": 0.5
            }
        
        # Êî∂ÈõÜÂêÑÁ≠ñÁï•ÊåáÊ†á
        strategy_metrics = {}
        for strategy_id in allocations:
            strategy_metrics[strategy_id] = self.get_strategy_metrics(strategy_id)
        
        # ËÆ°ÁÆóÂä†ÊùÉÊî∂Áõä
        weighted_return = 0.0
        weighted_sharpe = 0.0
        weighted_win_rate = 0.0
        
        for strategy_id, allocation in allocations.items():
            metrics = strategy_metrics[strategy_id]
            weighted_return += metrics.get("total_pnl", 0) * allocation
            weighted_sharpe += metrics.get("sharpe_ratio", 0) * allocation
            weighted_win_rate += metrics.get("win_rate", 0.5) * allocation
        
        # ËÆ°ÁÆóÂπ≥ÂùáÁõ∏ÂÖ≥ÊÄß
        avg_correlation = 0.0
        correlation_count = 0
        
        strategies = list(allocations.keys())
        for i in range(len(strategies)):
            for j in range(i+1, len(strategies)):
                correlation = abs(self.get_correlation(strategies[i], strategies[j]))
                avg_correlation += correlation
                correlation_count += 1
        
        if correlation_count > 0:
            avg_correlation /= correlation_count
        else:
            avg_correlation = 0.5  # ÈªòËÆ§ÂÄº
        
        # ËÆ°ÁÆóÂàÜÊï£Â∫¶ÊåáÊ†á (‰ΩéÁõ∏ÂÖ≥ÊÄß = È´òÂàÜÊï£Â∫¶)
        diversification = 1.0 - avg_correlation
        
        # ËÆ°ÁÆóÁªÑÂêàÊ≥¢Âä®ÊÄß (ÁÆÄÂåñÊ®°ÂûãÔºåÂÅáËÆæÁ≠ñÁï•Èó¥Êúâ‰∏ÄÂÆöÁõ∏ÂÖ≥ÊÄß)
        portfolio_risk = 0.0
        for strategy_id, allocation in allocations.items():
            metrics = strategy_metrics[strategy_id]
            strategy_risk = metrics.get("max_drawdown", 0.05)
            portfolio_risk += (strategy_risk * allocation) ** 2
        
        # ËÄÉËôëÁõ∏ÂÖ≥ÊÄßÂΩ±Âìç
        portfolio_risk = math.sqrt(portfolio_risk) * (0.5 + 0.5 * avg_correlation)
        
        # ÁªÑÂêàÊåáÊ†á
        return {
            "expected_return": weighted_return,
            "expected_risk": portfolio_risk,
            "sharpe_ratio": weighted_sharpe,
            "win_rate": weighted_win_rate,
            "correlation": avg_correlation,
            "diversification": diversification
        }


# Âçï‰æãÂÆû‰æã
_allocator_instance = None

def get_resource_allocator():
    """Ëé∑ÂèñÁ≠ñÁï•ËµÑÊ∫êÂàÜÈÖçÂô®ÂÆû‰æã"""
    global _allocator_instance
    if _allocator_instance is None:
        _allocator_instance = StrategyResourceAllocator()
    return _allocator_instance


if __name__ == "__main__":
    # ÊµãËØï‰ª£Á†Å
    allocator = StrategyResourceAllocator()
    
    # ÊµãËØïÁ≠ñÁï•ÊÄßËÉΩÊï∞ÊçÆÊõ¥Êñ∞
    try:
        allocator.update_strategy_performances_from_db()
        print("Á≠ñÁï•ÊÄßËÉΩÊï∞ÊçÆÊõ¥Êñ∞ÂÆåÊàê")
    except Exception as e:
        print(f"Êõ¥Êñ∞ÊÄßËÉΩÊï∞ÊçÆÂ§±Ë¥•: {e}")
    
    # ÊµãËØïËµÑÈáëÂàÜÈÖç
    test_strategies = ["momentum_1", "mean_reversion_1", "breakout_1", "grid_trading_1", "trend_following_1"]
    
    try:
        result = allocator.optimize_allocations(test_strategies, 10000.0)
        
        print("\nËµÑÈáëÂàÜÈÖçÁªìÊûú:")
        for strategy, amount in result["allocations"].items():
            print(f"{strategy}: {amount:.2f} USDT ({result['normalized'][strategy]:.2%})")
        
        print(f"\n‰øùÁïôËµÑÈáë: {result['reserve']:.2f} USDT")
        
        # ËÆ°ÁÆóÁªÑÂêàÊåáÊ†á
        metrics = allocator.get_portfolio_metrics(result["normalized"])
        print("\nÁªÑÂêàÊåáÊ†á:")
        print(f"ÊúüÊúõÊî∂Áõä: {metrics['expected_return']:.2%}")
        print(f"È¢ÑÊúüÈ£éÈô©: {metrics['expected_risk']:.2%}")
        print(f"Â§èÊôÆÊØîÁéá: {metrics['sharpe_ratio']:.2f}")
        print(f"ËÉúÁéá: {metrics['win_rate']:.2%}")
        print(f"Âπ≥ÂùáÁõ∏ÂÖ≥ÊÄß: {metrics['correlation']:.2f}")
        print(f"ÂàÜÊï£Â∫¶: {metrics['diversification']:.2f}")
        
        # ‰øùÂ≠òÁä∂ÊÄÅ
        allocator.save_state()
        
    except Exception as e:
        print(f"ËµÑÈáëÂàÜÈÖçÊµãËØïÂ§±Ë¥•: {e}")
        import traceback
        traceback.print_exc() 